using System;
using System.Runtime.InteropServices;
using NetRadio.Devices.Exceptions;

namespace NetRadio.Devices.G313
{
    /// <summary>
    /// Provides WinRadio G313 low level DSP access control.
    /// </summary>
    public class G313Dsp:IDisposable
    {
        /// <summary>
        ///Represents DSP resource memory segment.
        /// </summary>
        public enum DspResource:uint
        {
            /// <summary>
            /// First Segment
            /// </summary>
            One=G313Definitions.G313DspMask.WR_G313_DSP_1_1,
            /// <summary>
            /// Second Segment
            /// </summary>
            Two=G313Definitions.G313DspMask.WR_G313_DSP_1_2
        }

        private readonly G313Radio _parent;
        private uint _dspHandle;
        private G313Definitions.G313DspMask _dspResource;

        /// <summary>
        /// Occures when DSP is interrupted.
        /// </summary>
        public event EventHandler<EventArgs> DspInterrupted;

        private void DspCallback(IntPtr ptr)
        {
            OnDspInterrupted();
        }

        private void OnDspInterrupted()
        {
            if (DspInterrupted == null)
                return;

            DspInterrupted(this, EventArgs.Empty);
        }

        /// <summary>
        /// This is the first function that should be called when using the DSP. It announces the API and the driver that a specific range of resources in the DSP is required by the application so no other application will be allowed to access the same resources until they are freed. It also registers a callback function to the API that will be used when interrupts are generated by the DSP.
        /// </summary>
        /// <param name="resource"><see cref="DspResource"/> Specified segment.</param>
        public void Open(DspResource resource=DspResource.One)
        {
            _dspResource = (G313Definitions.G313DspMask)resource;

            _dspHandle= G313DspApi.dspOpen(_parent.Handle.ToInt32(),_dspResource, DspCallback, IntPtr.Zero);
            if (_dspHandle == 0)
                throw new OperationFailedException("failed to open dsp", _parent);
        }

        /// <summary>
        /// When the DSP resources are nolonger needed the API and the driver must be announced in order to allow other applications use them. That is done by calling dspClose. After it returns, the DSP handle is nolonger valid and DSP interrupts, even if previously enabled and not disabled through software, are nolonger dispatched for the closed handle. In order to allow maximum flexibility, the DSP is not automatically reset upon closing so it will continue running. This feature is very important when facilities like the “Mute audio on exit”, implemented in the standard G313i demodulator plug-in, are required.
        /// </summary>
        /// <returns>Returns true if DSP resources are closed.</returns>
        public bool Close()
        {
            return G313DspApi.dspClose(_parent.Handle.ToInt32(), _dspHandle);
        }

        /// <summary>
        /// Before loading the code into the DSP in order to boot, normally it should be reset, but there may be special situation in which such a behaviour is not desired. Depending on the current usage of the DSP resources, the driver may perform either a hardware or software reset. The initial DSP status after a software reset is unpredictable and thus any code used to boot it should do all the required initializations. Even with this small disadvantage, the software reset is very important when sharing the DSP between two applications.
        /// </summary>
        /// <returns>Returns true if DSP is successfully cycled on reset.</returns>
        public bool Reset()
        {
            return G313DspApi.dspReset(_parent.Handle.ToInt32(), _dspHandle, _dspResource);
        }

        /// <summary>
        /// Boots underlying DSP with provided firmware image.
        /// </summary>
        /// <param name="image"><see cref="IImage"/> Provided image.</param>
        /// <returns>Returns true if DSP is successfully booted with provided image.</returns>
        public bool Boot(IImage image)
        {
            using (image)
                return G313DspApi.dspBoot(_parent.Handle.ToInt32(), _dspHandle, _dspResource, image.LockBits(), image.Size);
        }

        /// <summary>
        /// This function reads data directly from the DSP memory and stores it in the specified application buffer. The position from which the read is done is application dependant and is given through Offset. This function accesses both the program and the data memories and the only way to differentiate between them is through the Offset value: program memory is located at 0x0000-0x3FFF and data memory is located at 0x4000-0x7FDF. For each program memory location there are two words that must be read from the DSP.
        /// </summary>
        /// <param name="buffer">The buffer into which the read data should be stored.</param>
        /// <param name="dspOffset">The DSP memory address from which the read should be started.</param>
        /// <param name="count">The size of the read buffer in words.</param>
        /// <returns>Returns true if the read succeeded and false if not.</returns>
        public bool Read(ushort[] buffer, uint dspOffset, int count)
        {
            var handle=GCHandle.Alloc(buffer,GCHandleType.Pinned);
            var result=G313DspApi.dspRead(_parent.Handle.ToInt32(), _dspHandle, _dspResource, dspOffset, handle.AddrOfPinnedObject(), (uint)count);
            handle.Free();
            return result;
        }

        /// <summary>
        /// This function writes data directly into the DSP memory from the specified application buffer. The position to which the write is done is application dependant and is given through Offset. This function accesses both the program and the data memories and the only way to differentiate between them is through the Offset value: program memory is located at 0x0000-0x3FFF and data memory is located at 0x4000-0x7FDF. For each program memory location there are two words that must be written to the DSP.
        /// </summary>
        /// <param name="buffer">The buffer from which the write data should be read.</param>
        /// <param name="dspOffset">The DSP memory address to which the write should be started.</param>
        /// <param name="count">The size of the write buffer in words.</param>
        /// <returns>Returns true if the write succeeded and false if not.</returns>
        public bool Write(ushort[] buffer, uint dspOffset, int count)
        {
            var handle = GCHandle.Alloc(buffer, GCHandleType.Pinned);
            var result = G313DspApi.dspWrite(_parent.Handle.ToInt32(), _dspHandle, _dspResource, dspOffset, handle.AddrOfPinnedObject(), (uint)count);
            handle.Free();
            return result;
        }

        /// <summary>
        /// This function reads data directly from the DSP memory and stores it in the specified application buffer. The position from which the read is done is application dependant and is given through Offset. This function accesses both the program and the data memories and the only way to differentiate between them is through the Offset value: program memory is located at 0x0000-0x3FFF and data memory is located at 0x4000-0x7FDF. For each program memory location there are two words that must be read from the DSP.
        /// </summary>
        /// <param name="buffer">The buffer into which the read data should be stored.</param>
        /// <param name="dspOffset">The DSP memory address from which the read should be started.</param>
        /// <param name="count">The size of the read buffer in bytes.</param>
        /// <returns>Returns true if the read succeeded and false if not.</returns>
        public bool Read(byte[] buffer, uint dspOffset, int count)
        {
            var handle = GCHandle.Alloc(buffer, GCHandleType.Pinned);
            var result = G313DspApi.dspRead(_parent.Handle.ToInt32(), _dspHandle, _dspResource, dspOffset, handle.AddrOfPinnedObject(), (uint)count/2);
            handle.Free();
            return result;
        }

        /// <summary>
        /// This function writes data directly into the DSP memory from the specified application buffer. The position to which the write is done is application dependant and is given through Offset. This function accesses both the program and the data memories and the only way to differentiate between them is through the Offset value: program memory is located at 0x0000-0x3FFF and data memory is located at 0x4000-0x7FDF. For each program memory location there are two words that must be written to the DSP.
        /// </summary>
        /// <param name="buffer">The buffer from which the write data should be read.</param>
        /// <param name="dspOffset">The DSP memory address to which the write should be started.</param>
        /// <param name="count">The size of the write buffer in bytes.</param>
        /// <returns>Returns true if the write succeeded and false if not.</returns>
        public bool Write(byte[] buffer, uint dspOffset, int count)
        {
            var handle = GCHandle.Alloc(buffer, GCHandleType.Pinned);
            var result = G313DspApi.dspWrite(_parent.Handle.ToInt32(), _dspHandle, _dspResource, dspOffset, handle.AddrOfPinnedObject(), (uint)count/2);
            handle.Free();
            return result;
        }

        public void Dispose()
        {
            var result = Close();
            if (!result)
                throw new OperationFailedException("failed to release dsp resources",_parent);
        }

        /// <summary>
        /// Gets Radio context
        /// </summary>
        /// <returns>Returns <see cref="G313Radio"/> instance.</returns>
        public G313Radio Radio()
        {
            return _parent;
        }

        internal G313Dsp(G313Radio parent)
        {
            _parent = parent;
        }
    }
}
